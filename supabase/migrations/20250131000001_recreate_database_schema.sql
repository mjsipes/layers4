-- Recreate the entire database schema based on TypeScript types

-- Create profiles table
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL,
    updated_at timestamp with time zone,
    username text,
    full_name text,
    avatar_url text,
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_username_key UNIQUE (username),
    CONSTRAINT profiles_username_check CHECK (char_length(username) >= 3)
);

-- Create layer table
CREATE TABLE IF NOT EXISTS public.layer (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text,
    description text,
    warmth smallint,
    top boolean,
    bottom boolean,
    user_id uuid,
    CONSTRAINT layer_pkey PRIMARY KEY (id)
);

-- Create weather table
CREATE TABLE IF NOT EXISTS public.weather (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    latitude double precision,
    longitude double precision,
    date date,
    weather_data jsonb,
    CONSTRAINT weather_pkey PRIMARY KEY (id)
);

-- Create log table
CREATE TABLE IF NOT EXISTS public.log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    date date,
    comfort_level smallint,
    feedback text,
    weather_id uuid,
    user_id uuid,
    latitude double precision,
    longitude double precision,
    address text,
    CONSTRAINT log_pkey PRIMARY KEY (id)
);

-- Create log_layer junction table
CREATE TABLE IF NOT EXISTS public.log_layer (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    log_id uuid DEFAULT gen_random_uuid(),
    layer_id uuid DEFAULT gen_random_uuid(),
    CONSTRAINT log_layer_pkey PRIMARY KEY (id)
);

-- Create recommendations table
CREATE TABLE IF NOT EXISTS public.recommendations (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid DEFAULT gen_random_uuid(),
    date date,
    layers uuid[] NOT NULL,
    reasoning text,
    CONSTRAINT recommendations_pkey PRIMARY KEY (id)
);

-- Add foreign key constraints
ALTER TABLE public.profiles ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;

ALTER TABLE public.layer ADD CONSTRAINT layer_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

ALTER TABLE public.log ADD CONSTRAINT log_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.log ADD CONSTRAINT outfit_log_weather_id_fkey FOREIGN KEY (weather_id) REFERENCES public.weather(id) ON DELETE SET NULL;

ALTER TABLE public.log_layer ADD CONSTRAINT log_layer_log_id_fkey FOREIGN KEY (log_id) REFERENCES public.log(id) ON DELETE CASCADE;
ALTER TABLE public.log_layer ADD CONSTRAINT outfit_layer_layer_id_fkey FOREIGN KEY (layer_id) REFERENCES public.layer(id) ON DELETE CASCADE;

ALTER TABLE public.recommendations ADD CONSTRAINT recommendations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.layer ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.log_layer ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.recommendations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.weather ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for profiles
CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- Create RLS policies for layer
CREATE POLICY "Users can view own layers" ON public.layer FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own layers" ON public.layer FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own layers" ON public.layer FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own layers" ON public.layer FOR DELETE USING (auth.uid() = user_id);

-- Create RLS policies for log
CREATE POLICY "Users can view own logs" ON public.log FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own logs" ON public.log FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own logs" ON public.log FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own logs" ON public.log FOR DELETE USING (auth.uid() = user_id);

-- Create RLS policies for log_layer
CREATE POLICY "Users can view own log_layer links" ON public.log_layer FOR SELECT USING (
  EXISTS (SELECT 1 FROM public.log WHERE log.id = log_layer.log_id AND log.user_id = auth.uid())
);
CREATE POLICY "Users can insert own log_layer links" ON public.log_layer FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM public.log WHERE log.id = log_layer.log_id AND log.user_id = auth.uid())
);
CREATE POLICY "Users can update own log_layer links" ON public.log_layer FOR UPDATE USING (
  EXISTS (SELECT 1 FROM public.log WHERE log.id = log_layer.log_id AND log.user_id = auth.uid())
);
CREATE POLICY "Users can delete own log_layer links" ON public.log_layer FOR DELETE USING (
  EXISTS (SELECT 1 FROM public.log WHERE log.id = log_layer.log_id AND log.user_id = auth.uid())
);

-- Create RLS policies for recommendations
CREATE POLICY "Users can view own recommendations" ON public.recommendations FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own recommendations" ON public.recommendations FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own recommendations" ON public.recommendations FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own recommendations" ON public.recommendations FOR DELETE USING (auth.uid() = user_id);

-- Create RLS policies for weather
CREATE POLICY "Users can view weather for their log locations" ON public.weather FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.log 
    WHERE log.user_id = auth.uid() 
    AND log.latitude = weather.latitude 
    AND log.longitude = weather.longitude
  )
);
CREATE POLICY "Allow weather data insertion" ON public.weather FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow weather data updates" ON public.weather FOR UPDATE USING (true);

-- Add unique constraints
ALTER TABLE public.weather ADD CONSTRAINT weather_location_date_unique UNIQUE (latitude, longitude, date);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_layer_user_id ON public.layer (user_id);
CREATE INDEX IF NOT EXISTS idx_log_user_id ON public.log (user_id);
CREATE INDEX IF NOT EXISTS idx_log_weather_id ON public.log (weather_id);
CREATE INDEX IF NOT EXISTS idx_log_layer_layer_id ON public.log_layer (layer_id);
CREATE INDEX IF NOT EXISTS idx_recommendations_user_id ON public.recommendations (user_id);
CREATE INDEX IF NOT EXISTS idx_weather_location ON public.weather (latitude, longitude, date);

-- Create functions (basic versions - you may need to recreate the full functions)
CREATE OR REPLACE FUNCTION public.calculate_outfit_warmth(outfit_uuid text)
RETURNS integer
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT COALESCE(SUM(l.warmth), 0)
  FROM public.log_layer ll
  JOIN public.layer l ON ll.layer_id = l.id
  WHERE ll.log_id = outfit_uuid::uuid;
$$;

-- Add more functions as needed... 